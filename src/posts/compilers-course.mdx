---
title: The compilers course
slug: /compilers-course
date: 2020-05-18
tags:
  - compilers
blogchains:
  - compilers-for-humans
---

One of the key pillars in Computer Science curriculum is "compilers". It's the course that not only evokes wonder, but trepidation.

I vividly remember holding the course book in my hands at the university bookstore a few days before class started. It was called _Compilers: Principles, Techniques, and Tools_ and is often revered as the seminal text on compilers.

The cover features a knight battling a dragon. It's supposed to represent you, as the knight, tackling the complexity of compilers, the dragon. All I could think about was the fact that I'm not sure this combat was a metaphor. It didn't exactly inspire confidence. I was in for it.

It was hefty, something like one thousand pages and originally written in 1986. As I rifled through it, I saw large blocks of the most unreadable pseudocode I'd ever seen. The algorithms looked complex, with mathematical symbols interwoven to literally look like Greek.

> I would soon find out it's endearingly referred to as the dragon book and is basically a meme in computer science circles.

Unsurprisingly, the course was challenging and so dry I couldn't stay awake. For our first project we had to write a parser that accepted a subset of the Java language. To add a bit of absurdity into the mix, we were required to print out our programs... on paper... for grading.

The day the project was due, there were thirty CS students with glazed eyes standing around the single printer in the CS lab. Many of us were up very late debugging null pointers in C. Now, to varying degrees of success we were waiting for our programs to print. Each program took an eternity and the smell of toner was strangely out of place.

When my program finally printed, I couldn't help but notice that I could staple mine whereas everyone else had to use binder clips. It was way fewer pages than everyone else's. I had missed the memo that we weren't allowed to use open source libraries and used GNU libraries in my project for reading files and data structures. Whoops.

I got a 9/100. This basically summarizes how the course turned out for me. I passed, but only because, with the curve, a 40% in the class was actually a 75%.

I left the class with new knowledge, but I felt like even more of an impostor in comparison to my peers.

I think that's why I felt compelled to begin [Compilers for Humans](https://compilersforhumans.com). There had to be a better way to teach the basics of compilers. We can make it human. We can make it visual. It'd be more fun if a compiler painted boxes to a screen rather than printed numbers and strings to a terminal. Yet most educational material is decades old and looks more like algebra rather than JavaScript.

The more folks that understand the underlying implementation of their tools, the more amazing stuff can be built by creating new DSLs or using compilers in new, novel ways.

The implications extend well beyond traditional developer tooling. Parsers, ASTs, and compilers can be used with natural language in order to warn authors when they use insensitive language. They can be used to augment design tools by importing or exporting production code. They can be used to transpile between formats to make tools interoperable.

The possibilities are endless.
